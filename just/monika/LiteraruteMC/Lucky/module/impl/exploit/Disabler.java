package just.monika.LiteraruteMC.Lucky.module.impl.exploit;

import just.monika.LiteraruteMC.Lucky.LuckyClient;
import just.monika.LiteraruteMC.Lucky.event.EventListener;
import just.monika.LiteraruteMC.Lucky.event.impl.game.WorldEvent;
import just.monika.LiteraruteMC.Lucky.event.impl.network.PacketReceiveEvent;
import just.monika.LiteraruteMC.Lucky.event.impl.network.PacketSendEvent;
import just.monika.LiteraruteMC.Lucky.event.impl.player.MotionEvent;
import just.monika.LiteraruteMC.Lucky.module.Category;
import just.monika.LiteraruteMC.Lucky.module.Module;
import just.monika.LiteraruteMC.Lucky.settings.impl.BooleanSetting;
import just.monika.LiteraruteMC.Lucky.settings.impl.ModeSetting;
import just.monika.LiteraruteMC.Lucky.settings.impl.NumberSetting;
import just.monika.LiteraruteMC.Lucky.utils.Utils;
import just.monika.LiteraruteMC.Lucky.utils.network.PacketUtils;
import just.monika.LiteraruteMC.Lucky.utils.time.TimerUtil;
import just.monika.LiteraruteMC.Lucky.module.impl.movement.Scaffold;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C00PacketKeepAlive;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.client.C0CPacketInput;
import net.minecraft.network.play.client.C0FPacketConfirmTransaction;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

@SuppressWarnings("unused")
public final class Disabler extends Module {
    private final ModeSetting mode = new ModeSetting("Mode", "Ping Abuser", "Ping Abuser", "Blink", "Watchdog", "Old Matrix", "Ghostly");
    //Ping Abuser
    private final NumberSetting abuseVL = new NumberSetting("Abuse VL", 100, 1000, 100, 1);
    private final BooleanSetting C0FAbuse = new BooleanSetting("C0F Abuse", true), C00Abuse = new BooleanSetting("C00 Abuse", true);
    private final List<Packet<?>> packetAbuseList = new CopyOnWriteArrayList<>();

    private TimerUtil timer1 = new TimerUtil(), timer2 = new TimerUtil(), abuseTimer = new TimerUtil();
    private TimerUtil timer = new TimerUtil();
    private Deque<Packet> packetsWD = new ArrayDeque<>();
    private ArrayList<Packet> packets = new ArrayList<>();
    private boolean cancel;

    public Disabler() {
        super("Disabler", Category.EXPLOIT, "Disables some anticheats");
        this.addSettings(mode, abuseVL, C0FAbuse, C00Abuse);
        abuseVL.addParent(mode, mode -> mode.is("ping abuser"));
        C0FAbuse.addParent(mode, mode -> mode.is("ping abuser"));
        C00Abuse.addParent(mode, mode -> mode.is("ping abuser"));
    }

    private final EventListener<MotionEvent> onMotion = e -> {
        if (Utils.mc.isSingleplayer()) return;
        if (timer1.hasTimeElapsed(10000, true)) {
            cancel = true;
            timer2.reset();
        }
        switch (mode.getMode()) {
            case "Ping Abuser":
                if (abuseTimer.hasTimeElapsed(abuseVL.getValue().longValue())) {
                    if (!packetAbuseList.isEmpty()) {
                        for (Packet<?> currentPacket : packetAbuseList) {
                            PacketUtils.sendPacketNoEvent(currentPacket);
                            packetAbuseList.remove(currentPacket);
                        }
                    }
                    abuseTimer.reset();
                }
                break;
            case "Ghostly":
                if(Utils.mc.thePlayer.ticksExisted % 15 == 0){
                    if (!packetAbuseList.isEmpty()) {
                        for (Packet<?> currentPacket : packetAbuseList) {
                            PacketUtils.sendPacketNoEvent(currentPacket);
                            packetAbuseList.remove(currentPacket);
                        }
                    }
                }
                break;
            case "Watchdog":
                break;
        }
    };

    private final EventListener<WorldEvent.Unload> onWorldLoad = e -> {
        packetAbuseList.clear();
        abuseTimer.reset();
        packetsWD.clear();
    };

    private final EventListener<PacketReceiveEvent> onPacketReceive = e -> {
    };

    private final EventListener<PacketSendEvent> onPacketSend = e -> {
        if (Utils.mc.isSingleplayer()) return;
        switch (mode.getMode()) {
            case "Ping Abuser":
                if (C0FAbuse.isEnabled()) {
                    if (e.getPacket() instanceof C0FPacketConfirmTransaction) {
                        C0FPacketConfirmTransaction packet = (C0FPacketConfirmTransaction) e.getPacket();
                        if (packet.getWindowId() > 100) {
                            packetAbuseList.add(packet);
                            e.cancel();
                        }
                    }
                }
                if (C00Abuse.isEnabled()) {
                    if (e.getPacket() instanceof C00PacketKeepAlive) {
                        packetAbuseList.add(e.getPacket());
                        e.cancel();
                    }
                }

                break;
            case "Blink":
                if(e.getPacket() instanceof C03PacketPlayer){
                    if(Utils.mc.thePlayer.ticksExisted % 3 == 0){
                        e.cancel();
                    }
                }
                break;
            case "Watchdog":

                // Strafe
                if (e.getPacket() instanceof C03PacketPlayer || e.getPacket() instanceof C03PacketPlayer.C04PacketPlayerPosition || e.getPacket() instanceof C03PacketPlayer.C06PacketPlayerPosLook) {
                    if (Utils.mc.thePlayer.ticksExisted < 50) {
                        e.cancel();
                    }
                }

                // Ping Spoof (Timer)
                if (e.getPacket() instanceof C03PacketPlayer) {
                    C03PacketPlayer c03 = (C03PacketPlayer) e.getPacket();
                    if (!c03.isMoving() && !Utils.mc.thePlayer.isUsingItem()) {
                        e.cancel();
                    }
                    if (cancel) {
                        if (!timer2.hasTimeElapsed(400, false)) {
                            if(!LuckyClient.INSTANCE.isToggled(Scaffold.class)) {
                                e.cancel();
                                packets.add(e.getPacket());
                            }
                        } else {
                            packets.forEach(PacketUtils::sendPacketNoEvent);
                            packets.clear();
                            cancel = false;
                        }
                    }
                }
                break;
            case "Old Matrix":
                if(e.getPacket() instanceof C03PacketPlayer){
                    C03PacketPlayer packetPlayer = (C03PacketPlayer) e.getPacket();

                    packetPlayer.y += 1E-5D;
                }
                break;
            case "Ghostly":
                if(e.getPacket() instanceof C0FPacketConfirmTransaction){
                    C0FPacketConfirmTransaction c0FPacketConfirmTransaction = (C0FPacketConfirmTransaction) e.getPacket();

                    if(c0FPacketConfirmTransaction.getWindowId() > 100){
                        packets.add(e.getPacket());
                        e.cancel();
                    }
                }

                if(e.getPacket() instanceof C00PacketKeepAlive){
                    packets.add(e.getPacket());
                    e.cancel();
                }

                if(e.getPacket() instanceof C03PacketPlayer){
                    if(Utils.mc.thePlayer.ticksExisted % 10 == 0){
                        e.cancel();
                    }
                    //Could ban idk tho lmao
                    PacketUtils.sendPacketNoEvent(new C0CPacketInput());
                }
                break;
        }
    };
}

